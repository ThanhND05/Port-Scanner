<!doctype html>
<html lang="en" class="h-full">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Port Scanner</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: #ffffff; color: #0f172a; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
    .card { background: linear-gradient(180deg, #ffffff, #f8fafc); }
    .small { font-size: 0.85rem; }
    .custom-scrollbar::-webkit-scrollbar { width: 8px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 4px; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
  </style>
</head>
<body class="h-full p-6">
  <div class="max-w-7xl mx-auto">
    <header class="flex items-center justify-between mb-6">
        <h1 class="text-2xl font-bold">Port Scanner</h1>
        
    </header>
    <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <section class="card rounded-lg p-5 col-span-1 lg:col-span-1 shadow">
            <h2 class="font-semibold mb-3">Scan Controls</h2>
            <form id="scanForm" class="space-y-3">
                <div><label class="small">Mode</label><select id="modeSelect" class="w-full p-2 rounded border bg-white"><option value="single">Single</option><option value="bulk">Bulk (Range / CIDR)</option></select></div>
                <div id="singleBlock"><label class="small">Target (IP or domain)</label><input id="targetInput" type="text" placeholder="127.0.0.1 or example.com" class="w-full p-2 rounded border" /></div>
                <div id="bulkBlock" class="hidden"><label class="small">IP Range (start-end)</label><input id="ipRangeInput" type="text" placeholder="192.168.1.1-192.168.1.254" class="w-full p-2 rounded border" /><label class="small mt-2 block">CIDR (one per line)</label><textarea id="cidrInput" rows="3" class="w-full p-2 rounded border" placeholder="192.168.0.0/24"></textarea></div>
                <div><label class="small">Custom Ports (comma / range allowed)</label><input id="portsInput" type="text" placeholder="22,80,443,8000-8010" value="80,443" class="w-full p-2 rounded border" /></div>
                <div><label class="small">Protocol</label><select id="protocolInput" class="w-full p-2 rounded border"><option value="tcp">TCP</option><option value="udp">UDP</option><option value="both">Both</option></select></div>
                <div class="flex gap-2">
                  <button id="startBtn" type="button" class="flex-1 p-2 bg-emerald-500 text-white rounded hover:bg-emerald-600">Start</button>
                  <button id="stopBtn" type="button" class="flex-1 p-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50" disabled>Stop</button>
                </div>
                <div class="flex gap-2"><button id="exportCsvBtn" type="button" class="flex-1 p-2 bg-slate-100 rounded border">Export CSV</button><button id="exportJsonBtn" type="button" class="flex-1 p-2 bg-slate-100 rounded border">Export JSON</button></div>
                
            </form>
        </section>
        <section class="card rounded-lg p-5 col-span-2 lg:col-span-2 shadow">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div class="p-4 rounded border text-center"><div class="text-sm text-slate-600">Open Ports</div><div id="openCount" class="text-3xl font-bold">0</div></div>
                <div class="p-4 rounded border text-center"><div class="text-sm text-slate-600">Closed Ports</div><div id="closedCount" class="text-3xl font-bold">0</div></div>
                <div class="p-4 rounded border text-center"><div class="text-sm text-slate-600">Progress</div><div class="text-3xl font-bold"><span id="progressPct">0</span>%</div></div>
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div class="lg:col-span-2">
                    <h3 class="font-semibold mb-2">Targets</h3>
                    <div class="rounded border max-h-96 overflow-y-auto custom-scrollbar">
                        <table id="targetsTable" class="w-full text-sm table-auto">
                            <thead class="text-slate-600 small sticky top-0 bg-slate-100">
                                <tr>
                                    <th class="p-2 text-center w-12">#</th><th class="p-2 text-left">Target</th><th class="p-2 text-left">Open Ports</th><th class="p-2 text-left">Closed Ports</th><th class="p-2 text-left">Elapsed</th>
                                </tr>
                            </thead>
                            <tbody id="targetsBody" class="mono small"></tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold mb-2">Top Open Ports</h3>
                    <canvas id="topPortsChart" height="200"></canvas>
                    <h3 class="font-semibold mt-4 mb-2">Realtime Log</h3>
                    <div id="log" class="mono text-xs p-3 rounded max-h-48 overflow-y-auto small text-slate-700 custom-scrollbar"></div>
                </div>
            </div>
        </section>
    </main>
    
  </div>
  <div id="toast" class="hidden fixed bottom-5 left-1/2 -translate-x-1/2 bg-emerald-600 text-white py-2 px-5 rounded-lg shadow-xl transition-opacity duration-500 z-50"></div>

<script>
(() => {
  let ws = null, scanning = false, results = [], scanStartTimestamp = 0;
  const wsPath = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws/scan`;

  // DOM elements
  const els = {
    modeSelect: document.getElementById('modeSelect'), singleBlock: document.getElementById('singleBlock'), bulkBlock: document.getElementById('bulkBlock'),
    targetInput: document.getElementById('targetInput'), ipRangeInput: document.getElementById('ipRangeInput'), cidrInput: document.getElementById('cidrInput'),
    portsInput: document.getElementById('portsInput'), protocolInput: document.getElementById('protocolInput'),
    startBtn: document.getElementById('startBtn'), stopBtn: document.getElementById('stopBtn'),
    exportCsvBtn: document.getElementById('exportCsvBtn'), exportJsonBtn: document.getElementById('exportJsonBtn'),
    openCount: document.getElementById('openCount'), closedCount: document.getElementById('closedCount'), progressPct: document.getElementById('progressPct'),
    targetsBody: document.getElementById('targetsBody'), log: document.getElementById('log'), toast: document.getElementById('toast'),
  };

  const topChart = new Chart(document.getElementById('topPortsChart').getContext('2d'), { type: 'bar', data: { labels: [], datasets: [{ data: [], backgroundColor: '#0ea5a4' }] }, options: { scales: { y: { beginAtZero: true } }, plugins: { legend: { display: false } } } });

  const showToast = (message, duration = 3000) => { els.toast.textContent = message; els.toast.classList.remove('hidden'); setTimeout(() => els.toast.classList.add('hidden'), duration); };
  const formatElapsed = ts => { const s = Math.floor(Date.now()/1000 - ts); return s < 60 ? `${s}s` : `${Math.floor(s/60)}m ${s%60}s`; };

  const addLog = line => {
    const el = document.createElement('div');
    el.textContent = `[${new Date().toLocaleTimeString()}] ${line}`;
    els.log.appendChild(el); // SỬA: Dùng append để log mới ở dưới
    els.log.scrollTop = els.log.scrollHeight; // Tự động cuộn xuống
  };

  const updateUI = (data) => {
    if (data.status === 'running') {
      els.openCount.textContent = data.open_ports;
      els.closedCount.textContent = data.closed_ports;
      const pct = (data.progress_total > 0) ? Math.round((data.progress_done / data.progress_total) * 100) : 0;
      els.progressPct.textContent = Math.min(100, pct);
    }
    if (data.top_ports) {
      const items = Object.entries(data.top_ports).sort((a,b) => b[1]-a[1]).slice(0, 12);
      topChart.data.labels = items.map(i => i[0]);
      topChart.data.datasets[0].data = items.map(i => i[1]);
      topChart.update();
    }
    if (data.new_result_line) {
      addLog(data.new_result_line);
      const m = /Target:\s*([^|]+)\s*\|\s*Open:\s*(\[.*?\])\s*\|\s*Closed:\s*(\[.*?\])/.exec(data.new_result_line);
      if (m) {
        const target = m[1].trim();
        const newOpenPorts = JSON.parse(m[2].replace(/'/g, '"'));
        const newClosedPorts = JSON.parse(m[3].replace(/'/g, '"'));

        let entry = results.find(r => r.target === target);
        if (!entry) {
            // Nếu target chưa có, tạo mới
            entry = { target, open_ports: [], closed_ports: [], ts: scanStartTimestamp };
            results.push(entry);
        }

        // SỬA 1: Nối (concat) mảng port thay vì ghi đè
        entry.open_ports = entry.open_ports.concat(newOpenPorts);
        entry.closed_ports = entry.closed_ports.concat(newClosedPorts);
        entry.elapsed = formatElapsed(entry.ts);

        // SỬA 2: Tìm dòng <tr> đã có để cập nhật, nếu không có thì mới tạo
        let tr = els.targetsBody.querySelector(`tr[data-target="${target}"]`);
        if (!tr) {
            tr = document.createElement('tr');
            tr.dataset.target = target; // Đặt định danh để tìm kiếm
            tr.className = 'border-b border-slate-200 last:border-b-0';
            els.targetsBody.appendChild(tr);
        }

        const rowIndex = results.findIndex(r => r.target === target) + 1;
        tr.innerHTML = `
            <td class="p-2 align-top text-center">${rowIndex}</td>
            <td class="p-2 align-top">${entry.target}</td>
            <td class="p-2 align-top break-all">${entry.open_ports.join(', ') || '<span class="text-slate-400">-</span>'}</td>
            <td class="p-2 align-top break-all">${entry.closed_ports.join(', ') || '<span class="text-slate-400">-</span>'}</td>
            <td class="p-2 align-top">${entry.elapsed}</td>
        `;
    }
    }
  };

  const resetState = () => {
    results = []; scanStartTimestamp = 0;
    ['openCount', 'closedCount', 'progressPct'].forEach(id => els[id].textContent = '0');
    els.targetsBody.innerHTML = ''; els.log.innerHTML = '';
    topChart.data.labels = []; topChart.data.datasets[0].data = []; topChart.update();
  };

  const stopScan = (message) => {
    addLog(message);
    scanning = false;
    els.startBtn.disabled = false;
    els.stopBtn.disabled = true;
  };
  
  els.modeSelect.addEventListener('change', () => {
    const isBulk = els.modeSelect.value === 'bulk';
    els.singleBlock.classList.toggle('hidden', isBulk);
    els.bulkBlock.classList.toggle('hidden', !isBulk);
  });

  els.startBtn.addEventListener('click', ev => {
    ev.preventDefault();
    if (scanning) return;

    const payload = { command: 'start', mode: els.modeSelect.value, ports: els.portsInput.value, protocol: els.protocolInput.value };
    if (payload.mode === 'single') payload.target = els.targetInput.value.trim();
    else { payload.ip_range = els.ipRangeInput.value.trim(); payload.cidr = els.cidrInput.value.trim(); }

    if ((payload.mode === 'single' && !payload.target) || (payload.mode === 'bulk' && !payload.ip_range && !payload.cidr)) {
      return addLog('Target/Range/CIDR is required.');
    }
    
    resetState();
    scanStartTimestamp = Math.floor(Date.now() / 1000);
    ws = new WebSocket(wsPath);

    ws.onopen = () => { addLog('WebSocket connected. Starting scan...'); ws.send(JSON.stringify(payload)); scanning = true; els.startBtn.disabled = true; els.stopBtn.disabled = false; };
    ws.onclose = () => { if (scanning) stopScan('WebSocket closed unexpectedly.'); };
    ws.onerror = () => stopScan('WebSocket error.');
    ws.onmessage = evt => {
      try {
        const data = JSON.parse(evt.data);
        if (data.type === 'error') return addLog(`Error: ${data.message}`);
        updateUI(data);
        if (data.status === 'done') {
          stopScan('Scan finished.');
          els.progressPct.textContent = '100';
          showToast('Scan finished successfully! ✅');
        } else if (data.status === 'stopped') {
          stopScan('Scan stopped by user.');
          showToast('Scan was stopped. 🛑', 2000);
        }
      } catch (e) { console.error('WS parse error', e); addLog('Failed to process message.'); }
    };
  });

  els.stopBtn.addEventListener('click', () => { if (ws && scanning) ws.send(JSON.stringify({ command: 'stop' })); });

  const exportData = (content, type, filename) => {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
  };

  els.exportCsvBtn.addEventListener('click', () => {
      if (!results.length) return alert('No results to export');
      const header = ['#', 'target', 'open_ports', 'closed_ports', 'elapsed'];
      const rows = results.map((r, i) => [i + 1, r.target, r.open_ports.join(';'), r.closed_ports.join(';'), r.elapsed]);
      const csv = [header, ...rows].map(r => r.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
      exportData(csv, 'text/csv', 'scan_results.csv');
  });

  els.exportJsonBtn.addEventListener('click', () => {
      if (!results.length) return alert('No results to export');
      exportData(JSON.stringify(results, null, 2), 'application/json', 'scan_results.json');
  });
})();
</script>
</body>
</html>